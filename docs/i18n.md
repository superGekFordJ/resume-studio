# Internationalization (i18n)

This document outlines the internationalization (i18n) strategy and implementation for the Resume Studio (简历工坊) application.

## 1. Technology Stack

- **`react-i18next`** and **`i18next`**: The core libraries for handling translations in React components.
- **`i18next-browser-languagedetector`**: A plugin to automatically detect the user's language from the browser settings.

## 2. File Structure

All translation files are located in the `public/locales` directory, organized by language code. Each language has three separate JSON files for better organization:

```
public/
└── locales/
    ├── en/
    │   ├── common.json      # Common terms (e.g., Close, Add, Select)
    │   ├── components.json  # Strings specific to React components
    │   └── schemas.json     # Strings derived from data schemas (e.g., field labels, placeholders)
    └── zh/
        ├── common.json
        ├── components.json
        └── schemas.json
```

## 3. Configuration (`src/i18n.ts`)

The main i18n configuration is located in `src/i18n.ts`.

Key features of the configuration:
- **SSR Compatibility**: To avoid issues with Server-Side Rendering (SSR), translation resources are imported directly into the configuration file. This preloads the translations on the server and prevents any backend from trying to fetch them via HTTP, which would fail in a server environment.
- **Language Detection**: The `i18next-browser-languagedetector` is used to set the initial language for the user.
- **Namespaces**: Translations are split into three namespaces (`common`, `components`, `schemas`) to keep the files organized and manageable. `common` is the default namespace.

## 4. Usage in Components

### 4.1. Basic Translation

To use translations in a component, import the `useTranslation` hook from `react-i18next`.

```tsx
import { useTranslation } from 'react-i18next';

function MyComponent() {
  // Specify the namespace(s) you need.
  // If no namespace is provided, 'common' is used by default.
  const { t } = useTranslation('components');

  return <h1>{t('Header.resumeStudio')}</h1>;
}
```

### 4.2. Using Multiple Namespaces

If a component needs strings from multiple files, you can pass an array to `useTranslation`.

```tsx
// Request 'components' and 'common' namespaces
const { t } = useTranslation(['components', 'common']);

// t() will search 'components' first, then 'common'.
// To avoid ambiguity, you can explicitly specify the namespace.
<Button>{t('dialog.close', { ns: 'common' })}</Button>
<p>{t('MyComponent.specificText')}</p> // Assumes this key is in 'components'
```

### 4.3. Translating Schema-Derived Content & Key Conventions

A core feature of Resume Studio is its schema-driven UI. All UI-facing strings for resume sections (field labels, placeholders, section titles) are defined as translation keys in `src/lib/schemas/defaultSchemas.ts`.

**This is a critical part of the i18n strategy.** To ensure consistency, we follow a strict naming convention for all schema-related keys.

#### 4.3.1. Key Naming Convention

The translation keys stored in the schema definitions **must** follow this pattern:

`schemas:{sectionId}.fields.{fieldKey}.{property}`

-   **`schemas:`** - This is a literal prefix that acts as a namespace identifier within the key itself.
-   **`sectionId`**: The unique ID of the resume section (e.g., `experience`, `education`).
-   **`fieldKey`**: The unique key for a field within that section (e.g., `jobTitle`, `degree`).
-   **`property`**: The UI property being translated (e.g., `label`, `placeholder`, `name`, `description`).

**Examples:**
- The `label` for the `jobTitle` field in the `experience` section is: `schemas:experience.fields.jobTitle.label`
- The `name` (title) of the `education` section itself is: `schemas:education.name`

This format makes the key's purpose self-documenting.

#### 4.3.2. Concrete Example

Here is a side-by-side example showing how a schema definition connects to the translation files.

**1. Schema Definition (`src/lib/schemas/defaultSchemas.ts`)**

The `jobTitle` field schema specifies its `label` and `placeholder` as full translation keys.

```typescript
// ... inside the 'experience' SectionSchema
jobTitle: {
  id: 'jobTitle',
  type: 'text',
  label: 'schemas:experience.fields.jobTitle.label', // <-- Full Key
  placeholder: 'schemas:experience.fields.jobTitle.placeholder', // <-- Full Key
  // ...
},
// ...
```

**2. English Translation (`public/locales/en/schemas.json`)**

The keys (without the `schemas:` prefix) are mapped to the English strings in a nested JSON structure.

```json
{
  "experience": {
    "fields": {
      "jobTitle": {
        "label": "Job Title",
        "placeholder": "e.g., Senior Software Engineer"
      }
    }
  }
}
```

**3. Usage in Components**

When a component renders this field, it uses the `useTranslation` hook. The `i18next` instance is configured to handle the `schemas:` prefix correctly.

```tsx
import { useTranslation } from 'react-i18next';

function Field({ fieldSchema }) {
  // It's common to get the translator for the 'schemas' namespace
  const { t: tSchema } = useTranslation('schemas');

  // i18next resolves 'schemas:experience.fields.jobTitle.label' to the correct string
  return <label>{tSchema(fieldSchema.label)}</label>;
}
```

This convention-based approach decouples the schema definition from the actual UI text, making the application fully localizable and maintainable.

## 5. Adding a New Language

To add a new language (e.g., French `fr`):

1.  Create a new directory `public/locales/fr`.
2.  Copy the three JSON files (`common.json`, `components.json`, `schemas.json`) from `public/locales/en` into the new `fr` directory.
3.  Translate the values in all three JSON files into French.
4.  Import the new `fr` translation files into `src/i18n.ts` and add them to the `resources` object.
5.  Add the new language option to the language switcher in `src/components/layout/SettingsPanel.tsx`.

```typescript
// src/i18n.ts

// ... import fr files
import frCommon from '../public/locales/fr/common.json';
// ...

const resources = {
  en: { /* ... */ },
  zh: { /* ... */ },
  fr: {
    common: frCommon,
    // ...
  },
};
```
